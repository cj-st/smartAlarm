<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\tomtom\layers\TrafficIncidentLayer.js - TomTom JavaScript SDK</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http://www.tomtom.com/global/images/tomtom-logo_tcm166-3340.png" title="TomTom JavaScript SDK"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/L.Control.Pan.html">L.Control.Pan</a></li>
            
                <li><a href="../classes/L.Control.ZoomSlider.html">L.Control.ZoomSlider</a></li>
            
                <li><a href="../classes/tomtom.AjaxUtil.html">tomtom.AjaxUtil</a></li>
            
                <li><a href="../classes/tomtom.Animation.html">tomtom.Animation</a></li>
            
                <li><a href="../classes/tomtom.controls.AutoComplete.html">tomtom.controls.AutoComplete</a></li>
            
                <li><a href="../classes/tomtom.controls.ContextMenu.html">tomtom.controls.ContextMenu</a></li>
            
                <li><a href="../classes/tomtom.controls.FindLocationControl.html">tomtom.controls.FindLocationControl</a></li>
            
                <li><a href="../classes/tomtom.controls.PanZoomBar.html">tomtom.controls.PanZoomBar</a></li>
            
                <li><a href="../classes/tomtom.controls.RouteControl.html">tomtom.controls.RouteControl</a></li>
            
                <li><a href="../classes/tomtom.controls.RoutePlannerControl.html">tomtom.controls.RoutePlannerControl</a></li>
            
                <li><a href="../classes/tomtom.controls.TabContainer.html">tomtom.controls.TabContainer</a></li>
            
                <li><a href="../classes/tomtom.CustomDivIcon.html">tomtom.CustomDivIcon</a></li>
            
                <li><a href="../classes/tomtom.CustomMarker.html">tomtom.CustomMarker</a></li>
            
                <li><a href="../classes/tomtom.dom.DomUtil.html">tomtom.dom.DomUtil</a></li>
            
                <li><a href="../classes/tomtom.dom.DomUtilResult.html">tomtom.dom.DomUtilResult</a></li>
            
                <li><a href="../classes/tomtom.layers.MapLayer.html">tomtom.layers.MapLayer</a></li>
            
                <li><a href="../classes/tomtom.layers.TrafficIncidentLayer.html">tomtom.layers.TrafficIncidentLayer</a></li>
            
                <li><a href="../classes/tomtom.layers.TrafficLayer.html">tomtom.layers.TrafficLayer</a></li>
            
                <li><a href="../classes/tomtom.layers.WMSLayer.html">tomtom.layers.WMSLayer</a></li>
            
                <li><a href="../classes/tomtom.LocaleManager.html">tomtom.LocaleManager</a></li>
            
                <li><a href="../classes/tomtom.Main.html">tomtom.Main</a></li>
            
                <li><a href="../classes/tomtom.Map.html">tomtom.Map</a></li>
            
                <li><a href="../classes/tomtom.Marker.html">tomtom.Marker</a></li>
            
                <li><a href="../classes/tomtom.MarkerManager.html">tomtom.MarkerManager</a></li>
            
                <li><a href="../classes/tomtom.services.GeocodingService.html">tomtom.services.GeocodingService</a></li>
            
                <li><a href="../classes/tomtom.services.HDTRegionsService.html">tomtom.services.HDTRegionsService</a></li>
            
                <li><a href="../classes/tomtom.services.InitializeService.html">tomtom.services.InitializeService</a></li>
            
                <li><a href="../classes/tomtom.services.LegacyGeocodingService.html">tomtom.services.LegacyGeocodingService</a></li>
            
                <li><a href="../classes/tomtom.services.RoutingService.html">tomtom.services.RoutingService</a></li>
            
                <li><a href="../classes/tomtom.services.TrafficService.html">tomtom.services.TrafficService</a></li>
            
                <li><a href="../classes/tomtom.services.ViewportService.html">tomtom.services.ViewportService</a></li>
            
                <li><a href="../classes/tomtom.StringBundle.html">tomtom.StringBundle</a></li>
            
                <li><a href="../classes/tomtom.TrafficMarker.html">tomtom.TrafficMarker</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src\tomtom\layers\TrafficIncidentLayer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define([
    &quot;../Utils&quot;,
    &quot;../lib/leaflet-encoded-polyline&quot;,
    &quot;../TrafficMarker&quot;,
    &quot;../services/TrafficService&quot;
  ],

  function(utils, PolylineUtils, TrafficMarker) {

    tomtom.layers.TrafficIncidentLayer = L.LayerGroup.extend({

      options: {

        styles: [
          { stroke: &quot;#ffffff&quot;, fill: &quot;#cccccc&quot; },
          { stroke: &quot;#ff8300&quot;, fill: &quot;#ffc700&quot; },
          { stroke: &quot;#a65500&quot;, fill: &quot;#ff8300&quot; },
          { stroke: &quot;#a60c00&quot;, fill: &quot;#ff1300&quot; },
          { stroke: &quot;#ffffff&quot;, fill: &quot;#cccccc&quot; }
        ],

        lineWidth: 8,
        strokeWidth: 2,
        arrowWidth: 16,
        arrowLength: 16

      },

      /**
       * Displays traffic incident icons as a layer above the base map.
       * It is recommended that this class is not used directly but rather the {{#crossLink &quot;tomtom.Map&quot;}}Map{{/crossLink}}&#x27;s displayTraffic
       * option is used like this:
       *
       *  var map = new tomtom.Map({
			 *    domNode: &quot;map&quot;,
			 *    displayTraffic: true
			 *  });
       *
       * @constructor
       * @class TrafficIncidentLayer
       * @namespace tomtom.layers
       * @extends L.LayerGroup
       * @param {String} apiKey The API key used to access the Map Toolkit API.
       * @param {String} trafficModel The starting traffic model used to access the traffic service.
       */
      initialize: function (apiKey, trafficModel) {

        // get the api key
        this.apiKey = apiKey;
        this.trafficModel = trafficModel;
        this._updateTimeout = 0;
        this._incidents = {};

        L.LayerGroup.prototype.initialize.apply(this, []);

      },

      onAdd: function() {

        L.LayerGroup.prototype.onAdd.apply(this, arguments);

        this._map.on(&quot;zoomanim&quot;, this._animateZoom, this);

      },

      onRemove: function() {

        this._map.off(&quot;zoomanim&quot;, this._animateZoom, this);

        L.LayerGroup.prototype.onRemove.apply(this, arguments);

      },

      /**
       * Updates the traffic incident icons using the specified traffic model.  The traffic model can be retrieved from a call to
       * the Viewport service.
       * @method update
       * @param {boolean} animation Whether or not to animate any markers that are updated.
       * @param {String} trafficModel The traffic model identifier which is passed to the traffic service.
       */
      update: function (animation, trafficModel) {

        this.trafficModel = trafficModel;

        clearTimeout(this._updateTimeout);

        // set a timeout so that the icons aren&#x27;t jumping around as the user zooms
        this._updateTimeout = setTimeout(L.Util.bind(function () {

          // default to show animations
          if (typeof(animation) == &quot;undefined&quot;) {
            animation = true;
          }

          var map = this._map,
            zoom = map.getZoom(),
            trafficService = new tomtom.services.TrafficService(this.apiKey),
            bounds = this._map.getBounds();

          if (zoom &gt;= 7) {

            // keep track of the incidents that were updated in this pass
            var update = new Date(),
              options = {
                projection: &quot;EPSG4326&quot;,
                trafficModelID: this.trafficModel
              },
              useVectorTrafficIncidents = map.options.useVectorTrafficIncidents;

            // supply geometries parameter to get vector traffic information
            if (useVectorTrafficIncidents) {
              if (typeof(useVectorTrafficIncidents) == &quot;boolean&quot;) {
                options.geometries = &quot;original&quot;;
              } else {
                options.geometries = useVectorTrafficIncidents;
              }
            }

            // get the traffic icons
            trafficService.getTrafficModel({ top: bounds.getNorthEast().lat, right: bounds.getNorthEast().lng, bottom: bounds.getSouthWest().lat, left: bounds.getSouthWest().lng }, zoom,
              options,
              L.Util.bind(function (response) {

                // make sure an actual traffic model was returned
                if (response.tm &amp;&amp; response.tm.poi) {

                  var incidents = this.incidents = response.tm.poi;

                  if (map.options.useVectorTrafficIncidents) {

                    var position = L.DomUtil.getPosition(map._mapPane);

                    // destroy the previous canvas
                    if (this._canvas) {
                      this._destroyCanvas(this._canvas);
                    }

                    // create the new canvas
                    this._canvas = this._createCanvas();

                    L.DomUtil.setPosition(this._canvas, new L.Point(-position.x, -position.y));

                    // keep the current bounds
                    this._currentBounds = map.getBounds();
                    this._currentZoom = map.getZoom();

                  }

                  // check to see if multiple incidents were returned
                  if (utils.isArray(incidents)) {
                    for (var incidentIndex = 0; incidentIndex &lt; incidents.length; incidentIndex++) {
                      this._addMarker(incidents[incidentIndex], update);
                    }
                  } else {
                    this._addMarker(incidents, update);
                  }

                  // fire the traffic update event
                  this._map.fire(&quot;trafficupdate&quot;, { incidents: incidents });

                  // remove markers for the incidents that are no longer in the window
                  for (var incidentId in this._incidents) {

                    var incidentMarker = this._incidents[incidentId];
                    if (incidentMarker._trafficIncidentUpdate != update) {

                      this.removeLayer(incidentMarker);
                      delete this._incidents[incidentId];

                    }

                  }

                } else {

                  if (this._canvas) {
                    this._destroyCanvas(this._canvas);
                    this._canvas = null;
                  }

                }

              }, this));

          } else {

            this.clearLayers();

            if (this._canvas) {
              this._destroyCanvas(this._canvas);
              this._canvas = null;
            }

          }

        }, this), 250);

      },

      /**
       * Sets the current traffic model.
       * @method setTrafficModel
       * @param {String} trafficModel The traffic model that should be used by the layer.
       */
      setTrafficModel: function (trafficModel) {

        this.trafficModel = trafficModel;

      },

      _addMarker: function (incident, update) {

        var marker = this._incidents[incident.id],
          geometry = incident.v,
          canvas = this._canvas;

        if (this._map.options.displayTrafficMarkers) {

          if (marker === null || marker === undefined) {

            marker = new TrafficMarker([incident.p.y, incident.p.x], incident);
            this.addLayer(marker);

          } else {

            marker.setLatLng([incident.p.y, incident.p.x]);
            marker._incident = incident;
            marker._configurePopup();

          }

          marker._trafficIncidentUpdate = update;
          this._incidents[incident.id] = marker;

        } else if (marker) {

          this.removeLayer(marker);

        }

        // add geometry to the canvas
        if (geometry &amp;&amp; canvas) {

          this._drawLine(incident, PolylineUtils.decode(geometry), canvas);

          this._done = true;

        }

      },

      _drawLine: function(incident, geometry, canvas) {

        var ctx = canvas.getContext(&quot;2d&quot;),
          map = this._map,
          point = null,
          style = this.options.styles[incident.ty],
          strokeStyle = style.stroke,
          fillStyle = style.fill,
          arrowWidth = this.options.arrowWidth,
          arrowLength = this.options.arrowLength,
          lineWidth = this.options.lineWidth,
          strokeWidth = this.options.strokeWidth;

        // build the arrow head
        var lastPoint = map.latLngToContainerPoint(geometry[geometry.length - 1]),
          nextToLastPoint = map.latLngToContainerPoint(geometry[geometry.length - 2]);

        ctx.beginPath();
        point = map.latLngToContainerPoint(L.latLng(geometry[0]));
        ctx.moveTo(point.x, point.y);

        for (var index = 1; index &lt; geometry.length; index++) {

          point = map.latLngToContainerPoint(geometry[index]);

          ctx.lineTo(point.x, point.y);

        }

        ctx.strokeStyle = strokeStyle;
        ctx.lineCap = &quot;round&quot;;
        ctx.lineWidth = lineWidth + (strokeWidth * 2);
        ctx.stroke();
        ctx.strokeStyle = fillStyle;
        ctx.lineWidth = lineWidth;
        ctx.stroke();

        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = strokeStyle;
        ctx.fillStyle = fillStyle;
        ctx.lineWidth = strokeWidth * 2;
        var dx = lastPoint.x-nextToLastPoint.x, dy=lastPoint.y-nextToLastPoint.y;
        ctx.translate(lastPoint.x,lastPoint.y);
        ctx.rotate(Math.atan2(dy,dx));
        ctx.moveTo(0, -(arrowWidth / 2));
        ctx.lineTo(arrowLength, 0);
        ctx.lineTo(0, arrowWidth / 2);
        ctx.closePath();
        ctx.stroke();
        ctx.fill();
        ctx.beginPath();
        ctx.lineCap = &quot;square&quot;;
        ctx.moveTo(-1, -lineWidth / 2 + strokeWidth);
        ctx.lineTo(-1, lineWidth / 2 - strokeWidth);
        ctx.lineWidth = strokeWidth * 2;
        ctx.strokeStyle = fillStyle;
        ctx.stroke();
        ctx.restore();

      },

      _destroyCanvas: function(canvas) {

        L.DomEvent.off(canvas, &quot;contextmenu&quot;, this._onContextMenu);
        this._map._panes.overlayPane.removeChild(canvas);

      },

      _createCanvas: function() {

        var map = this._map,
          size = map.getSize(),
          canvas = document.createElement(&quot;canvas&quot;);

        canvas.width = size.x;
        canvas.height = size.y;
        canvas.style.position = &quot;absolute&quot;;
        canvas.style.zIndex = 10;
        //canvas.style.display = &quot;none&quot;;
        canvas.className = &quot;leaflet-zoom-animated&quot;;

        L.DomEvent.on(canvas, &quot;contextmenu&quot;, this._onContextMenu);

        map._panes.overlayPane.appendChild(canvas);

        return canvas;

      },

      _onContextMenu: function(e) {

        e.preventDefault();
        return false;

      },

      _animateZoom: function (e) {

        if (!this._canvas || !this._currentBounds) {
          return;
        }

        var map = this._map,
          crs = map.options.crs,
          image = this._canvas,
          scale = crs.scale(e.zoom) / crs.scale(this._currentZoom),
          bounds = this._currentBounds,
          nw = bounds.getNorthWest(),
          se = bounds.getSouthEast(),
          topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
          size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
          origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

        image.style[L.DomUtil.TRANSFORM] =
          L.DomUtil.getTranslateString(origin) + &#x27; scale(&#x27; + scale + &#x27;) &#x27;;
      }

    });

    return tomtom.layers.TrafficIncidentLayer;

  });

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
